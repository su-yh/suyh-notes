一、Redis 缓存击穿
	原因及场景
		缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。
	解决方法
		1. 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
		2. 另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
二、Redis 缓存雪崩
	原因及场景
		缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
	解决方法
		缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程(进程)写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
三、Redis 的数据类型
	1. String
	2. Hash
	3. List
	4. Set 无序集合
	5. Zset 有序集合
		有序是指的利用score 评分来进行排序。
		集合主要的操作就是求交集、并集、差集。利用这个功能可以实现类似SQL 的AND OR 等操作
四、Hash 一致性
	Hash 一致性是Redis 2.x 版本引入的。它的引入是为了解决哨兵模式下Redis 增减节点而导致数据大量未命中问题。
	它是借助一个Hash 圆环来实现的，将Redis 节点映射到这个Hash圆环上，然后在存取数据时，对key 进行hash 运算也映射到这个圆环上。再顺时针找到的第一个节点就是这个key 存储的节点。
五、槽道
	槽道总数固定，有16384个。
	槽道主要分两部分
	1、16384 个二进制位
		每一个主节点下在的这个二进制位数据都是不同的
		每一个槽道有且仅有一个主节点管理。
		每一个节点下都管理着这样一个二进制位的数据。
		这个二进制位就表示这个下标位置的槽道是否归此节点管理。
	2、16384 个元素的数组
		每一个节点(包括主从)中的这个数据是完全相同的。
		数组的每一个下标就表示对应的槽道号；
		每一个元素里面存储着这个槽道相关的信息；
		这个槽道所归属的节点信息，以及存储的key 有哪些。
六、集群搭建
	一主二从
