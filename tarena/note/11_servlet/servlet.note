tomcat 官网：tomcat.apache.org

tomcat 下载与安装
    tomcat 分为windows 和linux以及32位和64位版本

    tomcat5 需要 JDK4 以上
    tomcat6 需要 JDK7 以上
    tomcat7 需要 JDK6 以上
    tomcat8 需要 JDK7 以上

    tomcat 压缩版本和安装版本

    启动需要JAVA_HOME 环境变量

    修改TOMCAT 的端口号，在conf/server.xml 中   Connector   标签里面有一个port 

    netstat -noa 查看当前正在使用网络的哪些进程，通过任务管理器找到对应PID 的进程，结束该进程则可以了。

tomcat 目录结构
    bin - 服务器存放批处理文件的目录
    conf - 服务器相关的配置
    lib - 依赖jar 包
    log - 日志文件
    temp - 临时文件
    webapps - 用来存放供外界浏览器访问的web 资源的目录，是localhost 虚拟主机默认管理的目录，将web 应用放在该目录下，可以通过浏览器来访问。
    work - 用来存放服务器在运行时产生的工作文件的目录。

WEB 应用
    所谓的WEB 应用，就是将为了实现某一个功能而准备所有WEB 资源根据自己所实现的功能按时一定的目录结构组织起来的就是一个WEB应用。
    WEB 应用的目录结构
        如果希望将一些资源发布在虚拟主机中供外界来访问，需要将这些资源组织成一个WEB 应用，将WEB 应用发布在虚拟主机中就可以让外界来访问了。
        news/
          |
          | -- html css js
          | -- WEB-INF 这是一个特殊的目录，放在该目录下的资源文件不能让浏览器直接访问
              | 
              | -- classes 目录  存放 .class 文件
              | -- lib 目录 - 用来存放web 应用运行时所依赖的jar 包
              | -- web.xml 文件  - 是WEB 应用的核心配置文件，所有和WEB 应用相关的配置都要在这个文件中进行配置！！

虚拟主机
    所谓的虚拟主机，就是运行在tomcat 服务器的一个站点(比如百度或者新浪), 在访问时就好像访问一台独立的主机一样。
    在tomcat 服务器中，可以配置多个站点，每一个站点都是一台虚拟主机。

如何部署WEB 应用到虚拟主机中
    在tomcat 服务器中提供了一个虚拟主机: localhost(截图: <a href="localhost.png">localhost.png</a>)
    因此我们可以将WEB 应用部署在localhost 主机上

    部署方式：将组织好的WEB 应用的目录直接丢进localhost 主机默认管理的目录下(webapps)即可，这种方式不需要重启服务器就可以起作用！！
        部署WEB 应用有三种方式，这里是第三种，第一种基本不用，第二种可以去看一下。

配置缺省的(默认的)WEB 应用
    如果再访问服务器中的WEB 应用下的资源时，如果不想写WEB 应用的虚拟目录的名称，可以将当前WEB 应用配置成缺省的WEB 应用。配置方式是将WEB 应用的虚拟目录名称改为ROOT 即可。    -- webapps/ROOT

如何为WEB 应用配置主页
    在WEB-INF/web.xml 中添加一个welcome-file-list 标签 里面再添加一个welcome-file 标签，在此标签下添加主页资源文件就可以了。配置完成之后需要重启TOMCAT 服务器，而且还要清除缓存。
        <!-- 配置访问主页资源 -->
        <welcome-file-list>
            <welcome-file>index.html</welcome-file>
        </welcome-file-list>
    如果自己的web.xml 中没有配置，但是在conf/web.xml 中的配置也是有效的。这个文件中的配置是对所有虚拟主机都有效的。
    如果自己web.xml 中配置了相关的数据，那么conf/web.xml 中的配置将被替换，且不生效。

如何配置虚拟主机
    需求: 配置一台主机，名称为www.baidu.com 组织一个WEB 应用并部署在baidu 主机中。并将WEB 应用配置为缺省的WEB 应用，最后配置WEB 应用的主页，最终通过www.baidu.com 来访问WEB 应用的主页
    在conf/server.xml 中添加Host 标签
    HOST 标签上的name 属性用来指定虚拟主机的名称，后期需要这个名称来访问该虚拟主机
    Host 标签上的appBase 属性用来批定虚拟主机默认管理的目录(用来部署WEB应用的目录)
    在配置好虚拟主机后，还不能通过浏览器来访问，因为还需要在hosts 文件中或者DNS 服务器中做域名和IP地址的映射关系。
    如果通过IP 地址来访问TOMCAT 服务器，服务器不知道客户端要访问哪一个虚拟主机，则会访问转为的虚拟主机。默认的虚拟主机可以通过server.xml 文件中的Engine 标签的defaultHost 属性来指定。

    这些配置好了一定要记得重启服务器，还有就是缓存清理一下。

打war 包
    $ jar -cvf 名称.war *
    然后将其放入到localhost 下面，它会自动解压。然后就可以访问了，tomcat 都不需要重启


HTTP 协议

2.1.2 HTTP 协议的基本原则
    1. 基于请求响应模型
    2. 一次请求对应一次响应
    3. 请求只能由客户端发出，服务器只能被动的等待请求做出回应。

2.2 HTTP 协议的详解
    2.2.1 HTTP 请求
        1. 请求行
            GET /news3/1.html HTTP/1.1
            GET: 请求方式，在HTTP 协议中一共规定了7 种请求方式
            /news3/1.html: 请求资源路径
            HTTP/1.1: 浏览器发送请求时所使用的协议及版本
        2. 若干请求头
            Accept: text/html,image/*
                -- 通知服务器当前浏览器可以接受哪些格式的数据
            Accept-Charset: ISO-8859-1
                -- 浏览器可以接受的字符集编码
            Accept-Encoding: gzip,compress
                -- 浏览器可以接受的压缩格式
            !Host: www.tedu.cn:80
                -- 需要访问的虚拟主机的名称
            !!Referer: http://www.tedu.cn/index.jsp
                -- 这是和防盗链相关的头，对当前资源的访问来自哪个页面的超链接
            User-Agent: Mozilla/4.0 (compatible, MSIE 5.5; Windows)
                -- 客户端的基本信息
            !!!Cookie(后面讲)
                -- 和cookei 相关的头
            Connection: close/Keep-Alive
                -- 是否继续保持连接
            Date: Fri, 17 Feb 2017 18:23:51 GMT
                -- 当前发送请求的时间
        3. 请求实体内容
            如果请求方式是GET 提交，请求实体中没有数据
            只有当请求方式为POST 提交，并且请求中携带了数据时，请求实体才会有内容
    2.2.2 HTTP 响应
        1. 状态行
            HTTP/1.1 200 OK
        2. 若干响应头
            HTTP 协议中响应头非常多，下面列出常见的响应头及其功能:
            !!!Location: http://www.tedu.cn/index.jsp
                -- 配合302 使用实现请求重定向
            Server: apache tomcat
                -- 服务器的基本信息
            Content-Encoding: gzip
                -- 服务器发送的数据使用的压缩格式
            Content-Length: 80
                -- 服务器发送的数据的大小
            !!!Content-Type: text/html; charset=GB2312
                -- 服务器发送的数据是什么格式的，如果是字符格式的数据
            !!Refresh: 1;url=http://www.tedu.cn
                -- 定时刷新相关的头，通知浏览器，过几秒后自动刷新访问哪一个网页
            Content-Disposition: attachment; filename=aaa.zip
                -- 通知浏览器以附件的形式打开发送过去的数据，是和文件下载相关的
            !!!Set-Cookie: SS=Q0=5Lb_n!; path=/search
                -- 和Cookie 相关的头
            !Expires: -1
                -- 通知浏览器是否缓存
            !Cache-Control: no-Cache
                -- 通知浏览器是否缓存
            !Pragma: no-Cache
                -- 通知浏览器是否缓存
                -- 之所以一个功能有三个头，是因为历史原因。所以为了网页的兼容性，通常这三个头要一起使用
            Connection: close/Keep-Alive
                -- 是否保持连接
            Date: Fri, 17 Feb 2017 18:23:51 GMT
                -- 当前发送请求的时间

        3. 响应实体内容
            

    3. GET 请求和POST 请求的区别
        主要体现在请求参数发送过程的不相同
        GET: 通过请求行拼接参数将数据发送给服务器
            (1) 通过地址栏携带参数非常不安全；
            (2) 通过地址栏发送数据，数据量不能太大(不能超过1KB或者4KB);
        POST: 通过请求实体内容携带参数，数据不会显示在地址栏
            (1) 参数不会出现在地址栏，相对更安全
            (2) 数据通过请求实体内容发送，数据量理论上没有限制







==========================================================================================================================================================================================================================

1. Servlet
1.1 Servlet 概述
    1.1.1 什么是Servlet?
        Servlet 是由SUN 公司提供的动态web 资源开发技术，本质上是一段JAVA 程序。这段JAVA 程序无法独立运行，必须放在Servlet 容器(比如: tomcat)中，由容器调用才可以执行。
    1.1.2 开发一个Servlet 程序的步骤
        1. 写一个类，实现一个Servlet 接口，并添加未实现的方法;
        2. 将编译后的类，放在WEB 应用中，并在WEB 应用web.xml 文件中配置Servlet 对外访问的虚拟路径。将WEB 应用部署到虚拟主机中即可;
    1.1.3 使用记事本开发一个Servlet 程序
        1. 需求：浏览器向服务器发送一个请求，访问FirstServlet，FirstServlet 将表示当前时间的字符串发送给浏览器;
        2. 详细开发步骤
            1). 创建一个FirstServlet.java 文件;
            2). 编写FirstServlet 类, 实现Servlet 接口，并添加未实现的方法(或者继承自GenericServlet);
            3). 实现Servlet 中提供的处理请求的servuce 方法，并将表示当前时间的字符串响应给浏览器;
            4). 打开cmd 窗口编译FirstServlet 类;
                带包编译: javac -d . FirstServlet.java -- -d 是指带包编译; . 是指当前目录 后面是源文件
            5). 将FirstServlet 类放在WEB 应用中，并在web.xml 文件中配置Servlet 对外访问的虚拟路径;
                将编译好的class 文件放到WEB 应用的WEB-INF/classes 目录下
                在WEB应用的web.xml 中配置servlet 对外访问的虚拟路径

                	<!-- server settings -->
                	<!-- 两个servlet-name 必须一致 -->
                	<servlet>
                		<servlet-name>FirstServlet</servlet-name>
                		<!-- servlet-name 对应的class 资源 -->
                		<servlet-class>com.tedu.servlet.FirstServlet</servlet-class>
                	</servlet>
                	<servlet-mapping>
                		<servlet-name>FirstServlet</servlet-name>
                		<!-- 浏览器上面指定的资源文件路径 -->
                		<url-pattern>/FirstServlet</url-pattern>
                	</servlet-mapping>

            6). 将WEB 应用部署到虚拟主机中，启动服务器，通过浏览器访问 FirstServlet;

1.2 Servlet 继承结构
    MyServlet --> HttpServlet --> GenericServlet-->Servlet

1.3 Servlet 调用过程(以及生命周期)
    开发一个Servlet，放在WEB 应用中，并将WEB 应用部署在服务器中，启动服务器，通过浏览器 访问Servlet, 可以访问到Servlet 处理的结果，这个Servlet 是如何被调用 的，Servlet 又是如何执行的。
    Servlet 在第一次被访问的时候创建实例，创建之后服务器会立即调用init 方法进行初始化操作，实例创建之后会一直驻留在服务器的内存中，为后续的请求服务。只要有请求访问这个Servlet，服务器就会调用service 方法来处理该请求。直到服务器关闭或者WEB应用被移出容器，随着WEB 应用的销毁，Servlet 实例也会跟着销毁，在销毁之前，服务器会调用destroy 方法进行善后的处理。

1.4 Servlet 开发细节
    1.4.1 Servlet 虚拟路径的配置
        Servlet 在web.xml 文件中虚拟路径的配置方式可以有两种方式: 
            1. 直接写一个路径，后期就需要通过/SecondsServlet 这个路径来访问该Servlet
                如：/SecondServlet
            2. 还可以使用(*) 匹配符来配置一个路径，配置的方式有两种: 
                a) 以斜杠(/) 开头，以斜杠星(/*) 结尾。
                    如：/*、/a/*、
                b) 以星点后缀(*.xxx) 的形式
                    如: *.html、*.abc、*.jsp
                使用(*) 匹配符可以使得路径的访问变更更加灵活，但是也可能会导致一个URL 会被多个mapping 所匹配。路径的优先级规则是什么？
                    i: 哪一个更精准，则优先匹配;
                    ii: *.xxx 的优先级是最低的; 



==========================================================================================================================================================================================================================
一、Request 对象
    代表HTTP 请求的一个对象
    浏览器向服务器发送一个请求，服务器在调用Servlet 的service 方法之前，会创建代表HTTP 请求的Request 对象，将所有的请求信息封装在Request 对象中。
    1.1 Request 的继承结构
        ServletRequest 接口  -- 通用的Request 接口，提供了一个Request 对象应该具有的功能
            |
            | -- HttpServletRequest 接口 -- 继承了ServletRequest 接口，在父接口的基础上HttpServletRequest 增加了一些和HTTP 协议的相关方法

    1.2 Request 对象提供的功能
        1.2.1 获取客户端基本信息、获取请求头信息
            1). getRequestURL 方法 -- 用于获取发送请求的完整url  // http://localhost/first/RequestDemo1
            2). getMethod 方法 -- 用于获取发送请求时使用的请求方式，这里只用GET 和POST 提交
            3). getContextPath 方法 -- 用于获取WEB 应用对外访问的虚拟路径，这个方法非常重要。在开发中当需要书写WEB 应用的虚拟路径时，最好不要写死，而是通过此方法来动态获取。
            4). getHeader(String name) 方法 // host: localhost
        1.2.2 获取请求参数(*)
            1). getParameter(String name); -- 通过请求参数的名字获取对应的参数值
            2). getParameterValues();
            3). getParameterMap();
            4). getParameterNames();

            * 请求参数的乱码问题
                如果发送方式是POST 提交，还可以通过request 提供的方法来解决乱码: request.setCharacterEncoding("utf-8"); 怕行代码是通知服务器使用UTF-8 来接收请求实体内容中的数据。
                由于POST 提交的参数刚才在请求实体内容中，所以这行代码可以解决POST 提交时产生乱码的问题
                但是由于GET 提交 的参数在请求行中的请求资源路径后面拼接着，不在请求行中，所以这行代码对GET 提交产生的乱码不会起作用。
        1.2.3 实现请求转发(*)
            请求重定向: 实现资源的跳转
            请求转发: 实现资源的跳转，并且是服务器内部的同一个WEB 应用内部资源的跳转
                实现请求转发: 
                    request.getRequestDispatcher("转到资源的URL 地址").forward(rquest, response);
                    1). 创建一个RequestDemo4 servlet 接收浏览器的请求，将请求转给RequestDemo5 来处理，RequestDemo5 处理请求，将结果响应给浏览器.
                        request.getRequestDispatcher("RequestDemo5").forward(request, response);
                    2). RequestDemo5 处理请求，将结果响应给浏览器.
                请求转的细节问题: 
                    1). 在转发时，转发时书写的资源路径是WEB 应用的虚拟路径后面的路径。
                    2). 在转发时，需要将代表请求的request 对象和代表响应的response 对象作为forward 方法的参数传递给被转发的资源。原因是不管转发多少次这些资源处理的请求和响应都是同一个。服务器针对同一个请求，只会创建一个request 对象和一个response对象，后面的资源在处理请求时又需要这两个对象，所以需要不断的传递这两个对象。
                    3). 转发不能进行多次，但是可以多重转发(比如：Demo4 转发给Demo5 ，Demo5 处理不了，转给Demo6，Demo6 转发给Demo7).
                    4). 如果在转发之前向response 缓冲区写入了数据，在转发时response 中的数据会被清空。
                    5). 如果在转发之前向response 缓冲区写入了数据，并且强制性(response.flushBuffer())发送给了浏览器，这时转发将会失败。
        1.2.4 作为域对象使用(*)
            域对象: 如果一个对象具有一个可以被看见的范围，利用这个对象上的map 集合，可以在这个范围内实现数据的共享。
                request 对象就是一个域对象，request 上提供了很多操作自身map 集合的方法。
                域对象都有以下几个方法
                request.setAttribute(String key, Object value);
                request.getAttribute(String key);
                request.removeAttribute(String key);
                request.getAttributeNames();    // 获取域对象中所有属性的名字组成的枚举。
            生命周期: 
            作用范围: 
            主要功能: 
            需求: 创建两个Servlet RequestDemo6 RequestDemo7, 在RequestDemo6 中将请求转发给RequestDemo7。在转发时负责带参数到RequestDemo7 中，并接收打印在控制台上。
                1). 创建两个Servlet;
                2). 在RequestDemo6 中将请求转发给RequestDemo7;
                3). 在RequestDemo6 中负责将参数带给RequestDemo7;
                4). 在RequestDemo7 中获取参数并打印在控制台;
        1.2.5 实现请求包含
            请求包含是服务器内部资源合并的一种效果
            假设浏览器发送请求访问服务器中的AServlet, AServlet 在处理请求的过程中，发现自己不能独立的来处理这次请求，需要另外一个Servlet 过来帮忙，这时可以在AServlet 中将BServlet 包含进来。然后由AServlet 和BServlet 共同来处理这次请求，AServlet 处理结果将会和BServlet 处理的结果合并在一起，一起响应给浏览器。
            示例：编写三个Servlet 分别为AServlet、BServlet、CServlet，实现Servlet 中的doGet 方法来处理请求。在BServlet 中将AServlet 和CServlet 包含进来，共同来处理请求。
            1). 创建三个Servlet; 
            2). 编写三个Servlet 的doGet 方法，处理请求;
            3). 在BServlet 中将AServlet 和CServlet 包含进来;
            4). 测试：访问BServlet 查看效果;

二、Response 对象
    代表HTTP 响应对象，用来封装服务器将要发送给浏览器的响应信息。
    1.1 继承结构
        ServletResponse 接口 - 提供了一个 response 对象应该具有的功能
            |
            |-- HTTPServletResponse 接口，继承了ServletResponse 接口，并添加了很多HTTP 协议相关的方法

    1.2 Response 提供的常用方法
        状态行
            HTTP/1.1 200 OK

        若干响应头
            key : value

        响应实体内容
            body

        设置状态码的方法
            setStatus
        设置响应头的方法
            setHeader
        设置响应实体内容的方法
            getOutputStream
            getWrite

    1.3 Response 对象提供的功能
        1.3.1 向客户端发送数据   getOutputStream 与getWrite 是互斥的，不能同时使用
            getOutputStream(字节流) 发中文数据时乱码解决方案: 将服务器与浏览器的编码都指定为同一个
                response.setContentType("text/html;charset=utf-8");
                response.getOutputStream().write("哈喽..response".getBytes("utf-8"));
                response.setHeader("Content-Type", "text/html;charset=utf-8");  // 通知对端按utf-8 来处理编码
            getWrite(字符流) 处理乱码
                response.setContentType("text/html;charset=utf-8"); // 同时处理服务器与浏览器的编码问题
                在我使用的过程中，如果这个编码设置在写数据的中间，则一样会出现乱码。必须要把它设置在开始部分。
            注意点: 
                1. 在一个请求中，getWrite和getOutputStream 不能同时使用，因为两个方法是互斥的，同时使用会抛异常;
                2. 通过getOutputStream 和getWrite 获取到的流，使用完后不需要关闭，因为服务器会自动帮我们关闭;
                3. 通过getWrite 和getOutputStream 这两个方法获取到的流，是指向response 缓冲区，而不是直接指向浏览器;

        1.3.2 实现请求重定向
            请求重定向: 可以实现资源的跳转
            实现请求重定向: 通过302 状态码和location 响应头可以实现重定向
                response.setStatus(302);
                response.setHeader("location", request.getContextPath() + "/index.html");
                等价于: response.sendRedirect("http://localhost:8080/second/index.html";
            重定向的特点: 
                两次请求，两次响应
                request 对象不是同一个
                地址栏会发生变化

        1.3.3 实现定时刷新
            通过refresh 头可以实现在多少秒之后跳转到指定的资源
            实现定时刷新
                response.setHeader("refresh", "3;url=" + request.getContextPath() + "/index.html");
            两次请求，两次响应
            request 对象不是同一个
            地址栏会发生变化
            和重定向的区别在于，重定向是立即发生跳转，而定时刷新是在指定多少秒之后发生跳转。并且在跳转之前，可以向浏览器发送响应，并维持一段时间。

        总结: 
            1). 三种资源跳转(请求转发、重定向、定时刷新)方式的区别; 
                请求转发
                    request.getRequestDispatcher("/index.html").forward(request, response);
                    一次请求，一次转发(request 对象是同一个)
                    地址栏不会发生变化
                    转发只能在同一个WEB 应用内部的资源之间进行跳转，不能在不同的WEB 应用或者不同的虚拟主机之间进行跳转
                重定向
                    两次请求，两次响应(request 对象不是同一个)
                    地址栏地址将会发生变化
                    重定向既可以在同一个WEB 应用内部的资源之间进行跳转，也可以在不同的WEB 应用或者不同的服务器以及虚拟主机之间进行跳转
                定时刷新
                    两次请求，两次响应(request 对象不是同一个)
                    地址栏会发生变化
                    重定向既可以在同一个WEB 应用内部的资源之间进行跳转，也可以在不同的WEB 应用或者不同的服务器以及虚拟主机之间进行跳转
                    定时刷新和重定向主要的区别在于，重定向是立即跳转，而定时刷新则是指定时间之后再进行跳转。并且在跳转之前，可以向浏览器发送响应数据并维持一段时间
            2). 请求转发、重定向、定时刷新分别在什么情况下使用;
                a). 如果是同一个WEB 应用内部资源的跳转，三种方式都可以做到。具体使用哪一种:
                    i). 如果希望在跳转之后地址栏地址不变，这里只能使用请求转发;
                    ii). 如果希望在跳转之后地址栏地址会发生变化，这里使用重定向或定时刷新;
                    iii). 如果在跳转的过程中，希望带数据到目的地，这里只能使用请求转发;
                    iv). 如果没有什么需求，仅仅是做一个跳转，推荐使用转;
                b). 如果是不同的WEB 应用之间资源的跳转，只能使用重定向和定时刷新，具体使用哪一种: 
                    i). 重定向是立即跳转，中间没有间隔，而定时刷新可以指定时间之后再进行跳转，而且在跳转之前还可以发送响应到客户端，并维持一段时间。因此如果需要指定多少时间之后再跳转，则可以使用定时刷新，如果跳转之前，

        1.3.4 控制浏览器的缓存行为
    	    // 通知浏览器不要缓存当前响应的资源
    	    response.setDateHeader("Expires", -1); // 1970-01-01 + (-1)
    	    response.setHeader("Cache-Control", "no-cache");

    	    response.setDateHeader("Expires", System.currentTimeMillis() + 1000 * 3600 * 24);
    	    response.setHeader("Cache-Control", "max-age=5");  // 优先级更高

            不同的浏览器或者相同的浏览器的不同版本，或者是相同的浏览器相同版本做了不同的设置他们之间的缓存行为可能都是不同的。
            如果我们希望浏览器能够缓存相关资源，或者缓存一段时间的数据




















































