tomcat 官网：tomcat.apache.org

tomcat 下载与安装
    tomcat 分为windows 和linux以及32位和64位版本

    tomcat5 需要 JDK4 以上
    tomcat6 需要 JDK7 以上
    tomcat7 需要 JDK6 以上
    tomcat8 需要 JDK7 以上

    tomcat 压缩版本和安装版本

    启动需要JAVA_HOME 环境变量

    修改TOMCAT 的端口号，在conf/server.xml 中   Connector   标签里面有一个port 

    netstat -noa 查看当前正在使用网络的哪些进程，通过任务管理器找到对应PID 的进程，结束该进程则可以了。

tomcat 目录结构
    bin - 服务器存放批处理文件的目录
    conf - 服务器相关的配置
    lib - 依赖jar 包
    log - 日志文件
    temp - 临时文件
    webapps - 用来存放供外界浏览器访问的web 资源的目录，是localhost 虚拟主机默认管理的目录，将web 应用放在该目录下，可以通过浏览器来访问。
    work - 用来存放服务器在运行时产生的工作文件的目录。

WEB 应用
    所谓的WEB 应用，就是将为了实现某一个功能而准备所有WEB 资源根据自己所实现的功能按时一定的目录结构组织起来的就是一个WEB应用。
    WEB 应用的目录结构
        如果希望将一些资源发布在虚拟主机中供外界来访问，需要将这些资源组织成一个WEB 应用，将WEB 应用发布在虚拟主机中就可以让外界来访问了。
        news/
          |
          | -- html css js
          | -- WEB-INF 这是一个特殊的目录，放在该目录下的资源文件不能让浏览器直接访问
              | 
              | -- classes 目录  存放 .class 文件
              | -- lib 目录 - 用来存放web 应用运行时所依赖的jar 包
              | -- web.xml 文件  - 是WEB 应用的核心配置文件，所有和WEB 应用相关的配置都要在这个文件中进行配置！！

虚拟主机
    所谓的虚拟主机，就是运行在tomcat 服务器的一个站点(比如百度或者新浪), 在访问时就好像访问一台独立的主机一样。
    在tomcat 服务器中，可以配置多个站点，每一个站点都是一台虚拟主机。

如何部署WEB 应用到虚拟主机中
    在tomcat 服务器中提供了一个虚拟主机: localhost(截图: <a href="localhost.png">localhost.png</a>)
    因此我们可以将WEB 应用部署在localhost 主机上

    部署方式：将组织好的WEB 应用的目录直接丢进localhost 主机默认管理的目录下(webapps)即可，这种方式不需要重启服务器就可以起作用！！
        部署WEB 应用有三种方式，这里是第三种，第一种基本不用，第二种可以去看一下。

配置缺省的(默认的)WEB 应用
    如果再访问服务器中的WEB 应用下的资源时，如果不想写WEB 应用的虚拟目录的名称，可以将当前WEB 应用配置成缺省的WEB 应用。配置方式是将WEB 应用的虚拟目录名称改为ROOT 即可。    -- webapps/ROOT

如何为WEB 应用配置主页
    在WEB-INF/web.xml 中添加一个welcome-file-list 标签 里面再添加一个welcome-file 标签，在此标签下添加主页资源文件就可以了。配置完成之后需要重启TOMCAT 服务器，而且还要清除缓存。
        <!-- 配置访问主页资源 -->
        <welcome-file-list>
            <welcome-file>index.html</welcome-file>
        </welcome-file-list>
    如果自己的web.xml 中没有配置，但是在conf/web.xml 中的配置也是有效的。这个文件中的配置是对所有虚拟主机都有效的。
    如果自己web.xml 中配置了相关的数据，那么conf/web.xml 中的配置将被替换，且不生效。

如何配置虚拟主机
    需求: 配置一台主机，名称为www.baidu.com 组织一个WEB 应用并部署在baidu 主机中。并将WEB 应用配置为缺省的WEB 应用，最后配置WEB 应用的主页，最终通过www.baidu.com 来访问WEB 应用的主页
    在conf/server.xml 中添加Host 标签
    HOST 标签上的name 属性用来指定虚拟主机的名称，后期需要这个名称来访问该虚拟主机
    Host 标签上的appBase 属性用来批定虚拟主机默认管理的目录(用来部署WEB应用的目录)
    在配置好虚拟主机后，还不能通过浏览器来访问，因为还需要在hosts 文件中或者DNS 服务器中做域名和IP地址的映射关系。
    如果通过IP 地址来访问TOMCAT 服务器，服务器不知道客户端要访问哪一个虚拟主机，则会访问转为的虚拟主机。默认的虚拟主机可以通过server.xml 文件中的Engine 标签的defaultHost 属性来指定。

    这些配置好了一定要记得重启服务器，还有就是缓存清理一下。

打war 包
    $ jar -cvf 名称.war *
    然后将其放入到localhost 下面，它会自动解压。然后就可以访问了，tomcat 都不需要重启


HTTP 协议

2.1.2 HTTP 协议的基本原则
    1. 基于请求响应模型
    2. 一次请求对应一次响应
    3. 请求只能由客户端发出，服务器只能被动的等待请求做出回应。

2.2 HTTP 协议的详解
    2.2.1 HTTP 请求
        1. 请求行
            GET /news3/1.html HTTP/1.1
            GET: 请求方式，在HTTP 协议中一共规定了7 种请求方式
            /news3/1.html: 请求资源路径
            HTTP/1.1: 浏览器发送请求时所使用的协议及版本
        2. 若干请求头
            Accept: text/html,image/*
                -- 通知服务器当前浏览器可以接受哪些格式的数据
            Accept-Charset: ISO-8859-1
                -- 浏览器可以接受的字符集编码
            Accept-Encoding: gzip,compress
                -- 浏览器可以接受的压缩格式
            !Host: www.tedu.cn:80
                -- 需要访问的虚拟主机的名称
            !!Referer: http://www.tedu.cn/index.jsp
                -- 这是和防盗链相关的头，对当前资源的访问来自哪个页面的超链接
            User-Agent: Mozilla/4.0 (compatible, MSIE 5.5; Windows)
                -- 客户端的基本信息
            !!!Cookie(后面讲)
                -- 和cookei 相关的头
            Connection: close/Keep-Alive
                -- 是否继续保持连接
            Date: Fri, 17 Feb 2017 18:23:51 GMT
                -- 当前发送请求的时间
        3. 请求实体内容
            如果请求方式是GET 提交，请求实体中没有数据
            只有当请求方式为POST 提交，并且请求中携带了数据时，请求实体才会有内容
    2.2.2 HTTP 响应
        1. 状态行
            HTTP/1.1 200 OK
        2. 若干响应头
            HTTP 协议中响应头非常多，下面列出常见的响应头及其功能:
            !!!Location: http://www.tedu.cn/index.jsp
                -- 配合302 使用实现请求重定向
            Server: apache tomcat
                -- 服务器的基本信息
            Content-Encoding: gzip
                -- 服务器发送的数据使用的压缩格式
            Content-Length: 80
                -- 服务器发送的数据的大小
            !!!Content-Type: text/html; charset=GB2312
                -- 服务器发送的数据是什么格式的，如果是字符格式的数据
            !!Refresh: 1;url=http://www.tedu.cn
                -- 定时刷新相关的头，通知浏览器，过几秒后自动刷新访问哪一个网页
            Content-Disposition: attachment; filename=aaa.zip
                -- 通知浏览器以附件的形式打开发送过去的数据，是和文件下载相关的
            !!!Set-Cookie: SS=Q0=5Lb_n!; path=/search
                -- 和Cookie 相关的头
            !Expires: -1
                -- 通知浏览器是否缓存
            !Cache-Control: no-Cache
                -- 通知浏览器是否缓存
            !Pragma: no-Cache
                -- 通知浏览器是否缓存
                -- 之所以一个功能有三个头，是因为历史原因。所以为了网页的兼容性，通常这三个头要一起使用
            Connection: close/Keep-Alive
                -- 是否保持连接
            Date: Fri, 17 Feb 2017 18:23:51 GMT
                -- 当前发送请求的时间

        3. 响应实体内容
            

    3. GET 请求和POST 请求的区别
        主要体现在请求参数发送过程的不相同
        GET: 通过请求行拼接参数将数据发送给服务器
            (1) 通过地址栏携带参数非常不安全；
            (2) 通过地址栏发送数据，数据量不能太大(不能超过1KB或者4KB);
        POST: 通过请求实体内容携带参数，数据不会显示在地址栏
            (1) 参数不会出现在地址栏，相对更安全
            (2) 数据通过请求实体内容发送，数据量理论上没有限制







==========================================================================================================================================================================================================================

1. Servlet
1.1 Servlet 概述
    1.1.1 什么是Servlet?
        Servlet 是由SUN 公司提供的动态web 资源开发技术，本质上是一段JAVA 程序。这段JAVA 程序无法独立运行，必须放在Servlet 容器(比如: tomcat)中，由容器调用才可以执行。
    1.1.2 开发一个Servlet 程序的步骤
        1. 写一个类，实现一个Servlet 接口，并添加未实现的方法;
        2. 将编译后的类，放在WEB 应用中，并在WEB 应用web.xml 文件中配置Servlet 对外访问的虚拟路径。将WEB 应用部署到虚拟主机中即可;
    1.1.3 使用记事本开发一个Servlet 程序
        1. 需求：浏览器向服务器发送一个请求，访问FirstServlet，FirstServlet 将表示当前时间的字符串发送给浏览器;
        2. 详细开发步骤
            1). 创建一个FirstServlet.java 文件;
            2). 编写FirstServlet 类, 实现Servlet 接口，并添加未实现的方法(或者继承自GenericServlet);
            3). 实现Servlet 中提供的处理请求的servuce 方法，并将表示当前时间的字符串响应给浏览器;
            4). 打开cmd 窗口编译FirstServlet 类;
                带包编译: javac -d . FirstServlet.java -- -d 是指带包编译; . 是指当前目录 后面是源文件
            5). 将FirstServlet 类放在WEB 应用中，并在web.xml 文件中配置Servlet 对外访问的虚拟路径;
                将编译好的class 文件放到WEB 应用的WEB-INF/classes 目录下
                在WEB应用的web.xml 中配置servlet 对外访问的虚拟路径

                	<!-- server settings -->
                	<!-- 两个servlet-name 必须一致 -->
                	<servlet>
                		<servlet-name>FirstServlet</servlet-name>
                		<!-- servlet-name 对应的class 资源 -->
                		<servlet-class>com.tedu.servlet.FirstServlet</servlet-class>
                	</servlet>
                	<servlet-mapping>
                		<servlet-name>FirstServlet</servlet-name>
                		<!-- 浏览器上面指定的资源文件路径 -->
                		<url-pattern>/FirstServlet</url-pattern>
                	</servlet-mapping>

            6). 将WEB 应用部署到虚拟主机中，启动服务器，通过浏览器访问 FirstServlet;

1.2 Servlet 继承结构
    MyServlet --> HttpServlet --> GenericServlet-->Servlet

1.3 Servlet 调用过程(以及生命周期)
    开发一个Servlet，放在WEB 应用中，并将WEB 应用部署在服务器中，启动服务器，通过浏览器 访问Servlet, 可以访问到Servlet 处理的结果，这个Servlet 是如何被调用 的，Servlet 又是如何执行的。
    Servlet 在第一次被访问的时候创建实例，创建之后服务器会立即调用init 方法进行初始化操作，实例创建之后会一直驻留在服务器的内存中，为后续的请求服务。只要有请求访问这个Servlet，服务器就会调用service 方法来处理该请求。直到服务器关闭或者WEB应用被移出容器，随着WEB 应用的销毁，Servlet 实例也会跟着销毁，在销毁之前，服务器会调用destroy 方法进行善后的处理。

1.4 Servlet 开发细节
    1.4.1 Servlet 虚拟路径的配置
        Servlet 在web.xml 文件中虚拟路径的配置方式可以有两种方式: 
            1. 直接写一个路径，后期就需要通过/SecondsServlet 这个路径来访问该Servlet
                如：/SecondServlet
            2. 还可以使用(*) 匹配符来配置一个路径，配置的方式有两种: 
                a) 以斜杠(/) 开头，以斜杠星(/*) 结尾。
                    如：/*、/a/*、
                b) 以星点后缀(*.xxx) 的形式
                    如: *.html、*.abc、*.jsp
                使用(*) 匹配符可以使得路径的访问变更更加灵活，但是也可能会导致一个URL 会被多个mapping 所匹配。路径的优先级规则是什么？
                    i: 哪一个更精准，则优先匹配;
                    ii: *.xxx 的优先级是最低的; 



==========================================================================================================================================================================================================================
一、Request 对象
    代表HTTP 请求的一个对象
    浏览器向服务器发送一个请求，服务器在调用Servlet 的service 方法之前，会创建代表HTTP 请求的Request 对象，将所有的请求信息封装在Request 对象中。
    1.1 Request 的继承结构
        ServletRequest 接口  -- 通用的Request 接口，提供了一个Request 对象应该具有的功能
            |
            | -- HttpServletRequest 接口 -- 继承了ServletRequest 接口，在父接口的基础上HttpServletRequest 增加了一些和HTTP 协议的相关方法

    1.2 Request 对象提供的功能
        1.2.1 获取客户端基本信息、获取请求头信息
            1). getRequestURL 方法 -- 用于获取发送请求的完整url  // http://localhost/first/RequestDemo1
            2). getMethod 方法 -- 用于获取发送请求时使用的请求方式，这里只用GET 和POST 提交
            3). getContextPath 方法 -- 用于获取WEB 应用对外访问的虚拟路径，这个方法非常重要。在开发中当需要书写WEB 应用的虚拟路径时，最好不要写死，而是通过此方法来动态获取。
            4). getHeader(String name) 方法 // host: localhost
        1.2.2 获取请求参数(*)
            1). getParameter(String name); -- 通过请求参数的名字获取对应的参数值
            2). getParameterValues();
            3). getParameterMap();
            4). getParameterNames();

            * 请求参数的乱码问题
                如果发送方式是POST 提交，还可以通过request 提供的方法来解决乱码: request.setCharacterEncoding("utf-8"); 怕行代码是通知服务器使用UTF-8 来接收请求实体内容中的数据。
                由于POST 提交的参数刚才在请求实体内容中，所以这行代码可以解决POST 提交时产生乱码的问题
                但是由于GET 提交 的参数在请求行中的请求资源路径后面拼接着，不在请求行中，所以这行代码对GET 提交产生的乱码不会起作用。
        1.2.3 实现请求转发(*)
            请求重定向: 实现资源的跳转
            请求转发: 实现资源的跳转，并且是服务器内部的同一个WEB 应用内部资源的跳转
                实现请求转发: 
                    request.getRequestDispatcher("转到资源的URL 地址").forward(rquest, response);
                    1). 创建一个RequestDemo4 servlet 接收浏览器的请求，将请求转给RequestDemo5 来处理，RequestDemo5 处理请求，将结果响应给浏览器.
                        request.getRequestDispatcher("RequestDemo5").forward(request, response);
                    2). RequestDemo5 处理请求，将结果响应给浏览器.
                请求转的细节问题: 
                    1). 在转发时，转发时书写的资源路径是WEB 应用的虚拟路径后面的路径。
                    2). 在转发时，需要将代表请求的request 对象和代表响应的response 对象作为forward 方法的参数传递给被转发的资源。原因是不管转发多少次这些资源处理的请求和响应都是同一个。服务器针对同一个请求，只会创建一个request 对象和一个response对象，后面的资源在处理请求时又需要这两个对象，所以需要不断的传递这两个对象。
                    3). 转发不能进行多次，但是可以多重转发(比如：Demo4 转发给Demo5 ，Demo5 处理不了，转给Demo6，Demo6 转发给Demo7).
                    4). 如果在转发之前向response 缓冲区写入了数据，在转发时response 中的数据会被清空。
                    5). 如果在转发之前向response 缓冲区写入了数据，并且强制性(response.flushBuffer())发送给了浏览器，这时转发将会失败。
        1.2.4 作为域对象使用(*)
            域对象: 如果一个对象具有一个可以被看见的范围，利用这个对象上的map 集合，可以在这个范围内实现数据的共享。
                request 对象就是一个域对象，request 上提供了很多操作自身map 集合的方法。
                域对象都有以下几个方法
                request.setAttribute(String key, Object value);
                request.getAttribute(String key);
                request.removeAttribute(String key);
                request.getAttributeNames();    // 获取域对象中所有属性的名字组成的枚举。
            生命周期: 
            作用范围: 
            主要功能: 
            需求: 创建两个Servlet RequestDemo6 RequestDemo7, 在RequestDemo6 中将请求转发给RequestDemo7。在转发时负责带参数到RequestDemo7 中，并接收打印在控制台上。
                1). 创建两个Servlet;
                2). 在RequestDemo6 中将请求转发给RequestDemo7;
                3). 在RequestDemo6 中负责将参数带给RequestDemo7;
                4). 在RequestDemo7 中获取参数并打印在控制台;
        1.2.5 实现请求包含
            请求包含是服务器内部资源合并的一种效果
            假设浏览器发送请求访问服务器中的AServlet, AServlet 在处理请求的过程中，发现自己不能独立的来处理这次请求，需要另外一个Servlet 过来帮忙，这时可以在AServlet 中将BServlet 包含进来。然后由AServlet 和BServlet 共同来处理这次请求，AServlet 处理结果将会和BServlet 处理的结果合并在一起，一起响应给浏览器。
            示例：编写三个Servlet 分别为AServlet、BServlet、CServlet，实现Servlet 中的doGet 方法来处理请求。在BServlet 中将AServlet 和CServlet 包含进来，共同来处理请求。
            1). 创建三个Servlet; 
            2). 编写三个Servlet 的doGet 方法，处理请求;
            3). 在BServlet 中将AServlet 和CServlet 包含进来;
            4). 测试：访问BServlet 查看效果;

二、Response 对象
    代表HTTP 响应对象，用来封装服务器将要发送给浏览器的响应信息。
    1.1 继承结构
        ServletResponse 接口 - 提供了一个 response 对象应该具有的功能
            |
            |-- HTTPServletResponse 接口，继承了ServletResponse 接口，并添加了很多HTTP 协议相关的方法

    1.2 Response 提供的常用方法
        状态行
            HTTP/1.1 200 OK

        若干响应头
            key : value

        响应实体内容
            body

        设置状态码的方法
            setStatus
        设置响应头的方法
            setHeader
        设置响应实体内容的方法
            getOutputStream
            getWrite

    1.3 Response 对象提供的功能
        1.3.1 向客户端发送数据   getOutputStream 与getWrite 是互斥的，不能同时使用
            getOutputStream(字节流) 发中文数据时乱码解决方案: 将服务器与浏览器的编码都指定为同一个
                response.setContentType("text/html;charset=utf-8");
                response.getOutputStream().write("哈喽..response".getBytes("utf-8"));
                response.setHeader("Content-Type", "text/html;charset=utf-8");  // 通知对端按utf-8 来处理编码
            getWrite(字符流) 处理乱码
                response.setContentType("text/html;charset=utf-8"); // 同时处理服务器与浏览器的编码问题
                在我使用的过程中，如果这个编码设置在写数据的中间，则一样会出现乱码。必须要把它设置在开始部分。
            注意点: 
                1. 在一个请求中，getWrite和getOutputStream 不能同时使用，因为两个方法是互斥的，同时使用会抛异常;
                2. 通过getOutputStream 和getWrite 获取到的流，使用完后不需要关闭，因为服务器会自动帮我们关闭;
                3. 通过getWrite 和getOutputStream 这两个方法获取到的流，是指向response 缓冲区，而不是直接指向浏览器;

        1.3.2 实现请求重定向
            请求重定向: 可以实现资源的跳转
            实现请求重定向: 通过302 状态码和location 响应头可以实现重定向
                response.setStatus(302);
                response.setHeader("location", request.getContextPath() + "/index.html");
                等价于: response.sendRedirect("http://localhost:8080/second/index.html";
            重定向的特点: 
                两次请求，两次响应
                request 对象不是同一个
                地址栏会发生变化

        1.3.3 实现定时刷新
            通过refresh 头可以实现在多少秒之后跳转到指定的资源
            实现定时刷新
                response.setHeader("refresh", "3;url=" + request.getContextPath() + "/index.html");
            两次请求，两次响应
            request 对象不是同一个
            地址栏会发生变化
            和重定向的区别在于，重定向是立即发生跳转，而定时刷新是在指定多少秒之后发生跳转。并且在跳转之前，可以向浏览器发送响应，并维持一段时间。

        总结: 
            1). 三种资源跳转(请求转发、重定向、定时刷新)方式的区别; 
                请求转发
                    request.getRequestDispatcher("/index.html").forward(request, response);
                    一次请求，一次转发(request 对象是同一个)
                    地址栏不会发生变化
                    转发只能在同一个WEB 应用内部的资源之间进行跳转，不能在不同的WEB 应用或者不同的虚拟主机之间进行跳转
                重定向
                    两次请求，两次响应(request 对象不是同一个)
                    地址栏地址将会发生变化
                    重定向既可以在同一个WEB 应用内部的资源之间进行跳转，也可以在不同的WEB 应用或者不同的服务器以及虚拟主机之间进行跳转
                定时刷新
                    两次请求，两次响应(request 对象不是同一个)
                    地址栏会发生变化
                    重定向既可以在同一个WEB 应用内部的资源之间进行跳转，也可以在不同的WEB 应用或者不同的服务器以及虚拟主机之间进行跳转
                    定时刷新和重定向主要的区别在于，重定向是立即跳转，而定时刷新则是指定时间之后再进行跳转。并且在跳转之前，可以向浏览器发送响应数据并维持一段时间
            2). 请求转发、重定向、定时刷新分别在什么情况下使用;
                a). 如果是同一个WEB 应用内部资源的跳转，三种方式都可以做到。具体使用哪一种:
                    i). 如果希望在跳转之后地址栏地址不变，这里只能使用请求转发;
                    ii). 如果希望在跳转之后地址栏地址会发生变化，这里使用重定向或定时刷新;
                    iii). 如果在跳转的过程中，希望带数据到目的地，这里只能使用请求转发;
                    iv). 如果没有什么需求，仅仅是做一个跳转，推荐使用转;
                b). 如果是不同的WEB 应用之间资源的跳转，只能使用重定向和定时刷新，具体使用哪一种: 
                    i). 重定向是立即跳转，中间没有间隔，而定时刷新可以指定时间之后再进行跳转，而且在跳转之前还可以发送响应到客户端，并维持一段时间。因此如果需要指定多少时间之后再跳转，则可以使用定时刷新，如果跳转之前，

        1.3.4 控制浏览器的缓存行为
    	    // 通知浏览器不要缓存当前响应的资源
    	    response.setDateHeader("Expires", -1); // 1970-01-01 + (-1)
    	    response.setHeader("Cache-Control", "no-cache");

    	    response.setDateHeader("Expires", System.currentTimeMillis() + 1000 * 3600 * 24);
    	    response.setHeader("Cache-Control", "max-age=5");  // 优先级更高

            不同的浏览器或者相同的浏览器的不同版本，或者是相同的浏览器相同版本做了不同的设置他们之间的缓存行为可能都是不同的。
            如果我们希望浏览器能够缓存相关资源，或者缓存一段时间的数据

三、ServletContext 对象
    域对象：如果一个对象具有可以被看见的范围，利用该对象上的map 可以在整个范围内，实现数据的共享。
        常用方法: 
            setAttribute(key, value);
            getAttribute(key);
            removeAttribute(key);
            getAttributeNames();

    3.1 ServletContext 对象简介
        ServletContext 对象是一个域对象
        代表整个WEB 应用的对象
        在服务器启动并加载WEB 应用之后，服务器会立即创建代表当前WEB 应用的ServletContext 对象，该对象会一直驻留在服务器的内存中，唯一的代表当前WEB 应用。在服务器关闭或者WEB应用被移除窗口，随着WEB 应用的销毁，ServletContext 对象也跟着销毁。

    3.2 获取ServletContext 对象
        ServletContext context = this.getServletContext();

        生命周期: 在WEB 应用被加载后，服务器立即创建代表当前的ServletContext 对象。在WEB 应用被移出窗口时，随WEB 应用的销毁，对象也跟着销毁。
        作用范围: 整个WEB 应用。
        主要功能: 在整个WEB 应用中实现数据的共享

    3.3 ServletContext 作为域对象使用
        需求: 统计本网站访问的人数，当用户访问本网站时，响应该用户是本网站今天是第几位访客！
        实现步骤: 
            1). 创建一个新的工程(WEB 应用) servlet_thread
            2). 创建两个Servlet(ServletContextDemo1、ServletContextDemo2)
            3). 在两个Servlet 中分别实现: 当用户访问时，响应该用户是本网站的第几位访问



==========================================================================================================================================================================================================================

会话技术
    1.1 会话技术的概述
        1.1.1 什么是会话
            为了实现某一个功能(购物), 浏览器和服务器之间可能会产生多次的请求和响应，从浏览器访问服务器开始，到访问服务器结束关闭浏览器位置，这期间产生的多次请求和响应加在一起称之为是浏览器和服务器之间的一次会话。
        1.1.2 会话中的数据存储
            在一次会话中往往会产生一些数据，而这些数据是需要保存起来的，如何在一次会话中保存所产生的数据呢？
            如果需要保存会话中产生的数据，可心考虑我们之前学习过的Request 域和ServletContext 域: 
                1). 如果使用Request 作用域来保存会话中产生的数据，由于会话是多次请求，多次响应，而Request 域的作用范围仅仅是一次请求，而以用Request  域保存会话中产生的数据 ，作用范围太小了;
                2). 如果使用ServletContext 作用域来保存会话中产生的数据，ServletContext 的作用范围是整个WEB 应用。如果将每一个浏览器与服务器产生的会话数据都保存在ServletContext 域中，很可能会发生混乱;

    1.2 Cookie
        1.2.1 Cookie 的工作原理
            Cookie 是通过Set-Cookie 响应头和Cookie 请求头将会话中产生的数据保存在客户端。是客户端的机制。
            客户端向服务器发送请求，服务器获取需要保存的数据，并将需要保存的数据通过Set-Cookie 响应头发送给浏览器，浏览器会以Cookie 的形式保存在浏览器的内部。
            当客户端再次发送请求访问服务器，服务器可以通过Cookie 请求头获取上次发送给浏览器的Cookie 信息。通过这种方式可以保存会话中产生的数据。
            由于Cookie 机制是将会话中产生的数据保存在客户端，每个客户端各自保存自己的数据，当需要时再带给服务器。因此不会发生混乱。

        1.2.2 如何创建Cookie
            // ***** 如果cookie 中有中文数据，那么他的编解码是怎么处理的呢？  这个编码直接使用response.setContentType() 就可以解决。
            1). 传统方式: 
        	    // 获取本次访问时间
        	    String strCurDate = new Date().toString();

        	    // 通过Set-Cookie 响应头将时间发送给浏览器保存
        	    response.setHeader("Set-Cookie", "time = " + strCurDate);

        	    // 通过Cookie 请求头获取上次访问时间
        	    String strPreDate = request.getHeader("Cookie");
        	    // 将时间作为响应数据发送给浏览器，并提示用户上次访问的时间
        	    response.setContentType("text/html;charset=utf-8");
        	    response.getWriter().write("您上次访问的时间: " + strPreDate);

            2). SUN 公司为了简化Cookie 的操作，提供了一套关于Cookie 的API: 
                Cookie cookie = new Cookie(String name, String value); // name = value
                cookie.getName(); // 获取Cookie 的名字
                cookie.getValue();  // 获取Cookie 的值
                cookie.setValue(String value);  // 设置Cookie 的值

        1.2.3 如何将Cookie 添加到响应中
            response.addCookie(Cookie cookie);

        1.2.4 如何获取请求中的Cookie
            Cookie[] cookies = request.getCookies();

        1.2.5 如何删除Cookie
            Cookie 的API 中没有提供直接删除Cookie 的方法，我们可以间接删除Cookie。可以向浏览器发一个同名、同path、同domain 的Cookie, 由于浏览器是根据Cookie 的名字 + path + domain 来区分一个Cookie 的，如果两个Cookie 的名字 + path + demain 完全一致，则浏览器会认为是同一个Cookie，这时后发的Cookie 会覆盖前一个Cookie, 而后发的Cookie 只要设置setMaxAge 的值为0，浏览器收到之后也会将后发的Cookie 立即删除。

            Cookie 的名字; time
            Cookie 的path: /servlet_fourth/
            Cookie 的存活时间是: 30 天

            再发一个Cookie
            Cookie 的名字; time
            Cookie 的path: /servlet_fourth/
            Cookie 的存活时间是: 0 秒

        1.2.6 常用方法
            1). setMaxAge   - 设置Cookie 的最大存活时间
                如果不设置存活时间，Cookie 默认是保存在浏览器的内存中。如果中途关闭浏览器，随着浏览器内存的释放，该Cookie 信息也随着内存的释放而丢失。
                如果设置该方法，Cookie 将会以临时文件的形式保存在浏览器的临时文件夹中。即使浏览器关闭，内存释放了，但是临时文件夹中的文件还存在，仍然可以获取到Cookie。
                Cookie cookie = new Cookie("time", strCurDate);
	            cookie.setMaxAge(3600);    // 1小时 = 3600
            2). setPath - 设置Cookie 被浏览器带回来的路径
                http://localhost/servlet_fourth/CookieDemo2
                       localhost/servlet_fourth/CookieDemo2
                localhost/servlet_fourth/ 根路径，及其子路径下的Cookie 则会被带回来。其他路径则不会被带回来。
                Cookie 默认被浏览器带回来的路径默认是发送Cookie 的Servlet 所在的路径(localhost/servlet_fourth/)，当访问该路径或者其子孙路径，则能带回Cookie 。否则带不回Cookie。
                cookie.setPath(request.getContextPath() + "/");   // "/servlet_fourth"  // 访问当前应用下所有Servlet 都会将Cookie 带回来
                比如发送的Cookie 的Servlet 为: http://localhost/servlet_fourth/CookieDemo2 Cookie 被浏览器带回来的路径就是CookieDemo2 所在的路径: http://localhost/servlet_fourth/
                这时，浏览器在访问servlet_fourth 应用下任何一个资源时都可以带着Cookie，如果Cookie 被带回来的路径不是WEB 应用的根路径，这时又希望浏览器在访问该应用下的任何一个资源时都能将Cookie 带回来，这时则需要设置Cookie 的路径为当前WEB 应用的根路径
                cookie.setPath(request.getContextPath() + "/"); // 备注：后面拼上"/" 目的是：如果当前WEB 应用是缺省的WEB 应用，通过getContextPath() 获取到的WEB 应用的路径为一个空字符串，而路径不能为空，所以后面需要拼上一个"/";

        1.2.7 在网页中显示上次访问时间
            需求：当用户访问网站时，可以获取到上次访问的时间。
            实现步骤：
                1). 创建一个工程(servlet_fouth) 
                2). 创建一个Servlet(CookieDemo1)
                3). 实现CookieDemo1:
                    a). 先记录(获取) 本次访问的时间(比如: 2017-12-06 11:40:32);
                    b). 将本次访问的时间以Set-Cookie 响应头响应给浏览器保存;
                    c). 通过Cookie 请求头获取上次访问的时间，将时间响应给浏览器(提示用户上次访问时间为xxx);

        1.2.8 生命周期
            随便浏览器的关闭，Cookie 释放。Cookie 是在浏览器内存中保存的。如果设置存活时间，则Cookie 将会保存在缓存文件中，下次可以从缓存文件中获取。

    1.3 Session
        1.3.1 Session 的工作原理

        1.3.2 Session 是一个域对象

        1.3.3 实现一个购物车


















































